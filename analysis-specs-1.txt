Analysis specs:
Given a tab separated file "raw_data.tsv" that has the following columns (specified in the header):
conv_id
complaint_disat
segment_id
call_duration
reason_level_1
reason_level_2
plain_whisper
language_code

together with this code that extracts a datframe from the file:
#==============================================
# Input data
#==============================================
dir = '/chunk-complaints/categories/'
filename = 'metadata-labeled-conversations.txt'

import pandas as pd

#=======================================================================
# Read TSV file and return pandas df that excludes spanish language rows
#=======================================================================
def getTSVData(filename, sep='\t'):
    data = pd.read_csv(filename, sep=sep)
    return data

def rejectSpanish(data):
    data = data[data['plain_whisper'].apply(lambda x: 'gracias' not in str(x).lower())]
    return data

The dataframe obtained from rejectSpanish will be used as input to the following function
1. Given a define a function "rejectReasonLevels" that rejects any rows whose reason_level_1 contains tokens in a an input dataframe, and a list initialized to:
["CTRL SQL Database", "tbd"]
2. Given a dataframe (eg. the one obtained from rejectReasonLevels), write a function "showReasonDistribution" that will print a list of tab-separated lines for each reason_level_1, where each line contains:
unique value of reason_level_1
number of conv_id lines associated with reason_level_1
comma-separated list of individual tokens in the string value of reason_level_1

To print the individual tokens, treat non alphanumeric characters as spaces and separate the resulting string on spaces.

"showReasonDistribution" will also write each line to a file named "category_biz_labels.txt"

#=============================================
# Remove level-1 reasons not required
#=============================================
def rejectReasonLevels(data, levels_list=["CTR SQL Database", "tbd"]):
    # Convert the 'reason_level_1' column to strings
    data['reason_level_1'] = data['reason_level_1'].astype(str)
    
    for level in levels_list:
        # Case insensitive search
        data = data[~data['reason_level_1'].str.contains(level, case=False)]
    return data

#=============================================
# Show distribution of reason level 1
#=============================================
def showReasonDistribution(data, filename):
    reason_counts = data['reason_level_1'].value_counts()

    with open(filename, 'w') as f:
        for reason, count in reason_counts.items():
            reason_cleaned = re.sub('\W+', ' ', reason)
            tokens = reason_cleaned.split()
            print(f'{reason}\t{count}\t{",".join(tokens)}')
            f.write(f'{reason}\t{count}\t{",".join(tokens)}\n')


show a bar chart of reason_level_1 vs count

#=============================================
# Plot distribution of reason level 1
#=============================================
import matplotlib.pyplot as plt

def plotReasonDistribution(data, include_not_a_complaint=True):
    # Filter out 'Not a Complaint' rows if include_not_a_complaint is False
    if not include_not_a_complaint:
        data = data[data['reason_level_1'] != 'Not a Complaint']
        
    reason_counts = data['reason_level_1'].value_counts()

    # Sorting the counts in ascending order
    reason_counts = reason_counts.sort_values(ascending=True)

    # Increase the font size using plt.rc
    plt.rc('font', size=12) # controls default text size
    plt.rc('axes', titlesize=20) # controls axis title size
    plt.rc('axes', labelsize=20) # controls x and y labels size
    plt.rc('xtick', labelsize=12) # controls tick labels size
    plt.rc('ytick', labelsize=20) # controls tick labels size
    plt.rc('legend', fontsize=12) # controls legend size

    # Plotting
    plt.figure(figsize=(20,10))  # Adjust the size of the figure as per your needs
    reason_counts.plot(kind='barh')  # Changed to 'barh' for horizontal bars
    plt.ylabel('Reason Level 1')
    plt.xlabel('Count')
    if include_not_a_complaint:
        plt.title('Distribution of Reason Level 1')
        plt.savefig('plotWithComplaint.png', dpi=300)
    else:
        plt.title('Distribution of Reason Level 1 excluding "Not a Complaint"')
        plt.savefig('plotWithoutComplaint.png', dpi=300)

    # Add count annotations to each bar
    for index, value in enumerate(reason_counts):
        plt.text(value, index, str(value), fontsize=20)
        
    plt.tight_layout()
    plt.show()

--------------------------- show compact data
I want to make a compact "cheat sheet" that can be displayed on single printed page. It's also ok to take a screenshot and print that. The data I want to show will come from the data generated using this function: showReasonDistribution(data, filename)

#=============================================
# Tabulate reasons and counts
#=============================================
from tabulate import tabulate

def showReasonDistribution(data, filename):
    reason_counts = data['reason_level_1'].value_counts()

    # Convert the series to a DataFrame
    df = reason_counts.reset_index()
    df.columns = ['reason_level_1', 'count']

    # Sort dataframe by count in descending order
    df.sort_values('count', ascending=False, inplace=True)

    # Prepare the data for tabulate
    rows = df.shape[0]
    third = -(-rows // 3)  # Equivalent of ceiling division

    # Split the dataframe into 3 equal parts
    df1, df2, df3 = df.iloc[:third], df.iloc[third:2*third], df.iloc[2*third:]

    # Create a single dataframe from the 3 parts
    df = pd.concat([df1.reset_index(drop=True), df2.reset_index(drop=True), df3.reset_index(drop=True)], axis=1)

    # Write the dataframe to a text file using tabulate
    with open(filename, 'w') as f:
        f.write(tabulate(df, headers='keys', tablefmt='psql', showindex=False))

    print(tabulate(df, headers='keys', tablefmt='psql', showindex=False))
