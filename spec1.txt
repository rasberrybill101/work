from fastapi import FastAPI, Query

app = FastAPI()

@app.get("/example")
async def example(param1: str = Query(...), param2: int = Query(...)):
    response = {
        "param1": param1,
        "param2": param2,
        "sum": param1 * param2
    }
    return response

===================================================================
Python fast api POST method that receives a JSON input of the form:
{ "chunk": "this is the input text",
  "history": "these are the previous chunks"
}

from fastapi import FastAPI
from pydantic import BaseModel

class Chunk(BaseModel):
    chunk: str
    history: str

app = FastAPI()

@app.post("/chunks/")
async def create_chunk(chunk: Chunk):
    return chunk


=================================================================
using python create a function "getLastK(k) to return the last k tokens of a space separated string

def getLastK(k, input_string):
    tokens = input_string.split()
    if len(tokens) < k:
        return input_string
    last_k_tokens = tokens[-k:]
    return " ".join(last_k_tokens)

======================== search for level-1 within the conv. ==========
lmplement the following python function in a case-insensitive way:
Given a csv file with columns 

Only process rows where column "complaint-disat" has the value:
"complaint"

Ignore rows where level-1 has the following values:
'*Case ID no Longer in CTR SQL Database'
'*Number did not match case'

for each row to be processed:
take the string in level-1 column, replace non-alpha characters such as '(', ')', '/', '-' with a space
ensure that only single spaces are between words
trim the string

search for the first occurrence of either this string or the longest sub-sequence of this string within the column "plain-whisper". 

Find the longest sequence of words in the plain_whisper column that can be found in the level-1 column (after all the non-alpha characters in the level-1 column have been replaced with space characters as described previously). For example:
Given level-1 : "Call Transfers/Disconnects"
possible sequences are "call transfers disconnects", "call transfers", "call", "transfers", "transfers disconnects", "call disconnects", "disconnects"
In this example, the longest sequence in level-1 is "call transfers disconnects". If this substring is found in the "plain_whisper" column, then it will be selected as the "longest_candidate" string. Otherwise, search for any other possible identified sequence. If none can be found, then return "No Direct Sequence Found"

To summarize, the sequence of tokens is initially identified from level-1 tokens and then we search for them in plain_whisper column.
If a sequence is found in "plain_whisper" column, then add the tokens before  the longest_candidate starting from the first period to the left of the longest_candidate. Also add the tokens to the right of the longest_candidate tokens until the period to the right. Return this string from the function.
For example, in the string:
"it would seem simple. But we know that the quick brown fox jumps over the lazy dog quite quickly indeed. Today is when we find out."
if the sequence is: "jumps over"
then the returned string will be:
"But we know that the quick brown fox jumps over the lazy dog quite quickly indeed"
This is basically the first sentence that contains the longest sub-sequence

complete processing all relevant rows before writing the following results to a csv file named "level-1-phrases.txt" which has the following columns:
1) conv-id
2) level-1
3) plain_whisper
4) sequence
5) left character position of the returned sentence 
6) right character position of the returned sentence


